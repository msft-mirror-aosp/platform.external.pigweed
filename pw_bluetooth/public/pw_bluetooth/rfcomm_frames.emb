# Copyright 2024 The Pigweed Authors
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may not
# use this file except in compliance with the License. You may obtain a copy of
# the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations under
# the License.

# This file contains Emboss definitions for the logical link control and
# adaptation protocol (l2cap) frames found in the Bluetooth core specification.
# The Emboss compiler is used to generate a C++ header from this file.

[$default byte_order: "LittleEndian"]
[(cpp) namespace: "pw::bluetooth::emboss"]
# ========================= RFCOMM Frame Format =================================
# RFCOMM Spec v1.2
# Also see: ETSI TS 07.10

enum RfcommFrameType:
  -- ETSI TS 07.10 section 5.2.1.3
  [maximum_bits: 8]
  SET_ASYNC_BALANCED_MODE = 0x2f
  UNNUMBERED_ACK = 0x63
  DISCONNECT_MODE = 0x0f
  DISCONNECT = 0xc3
  UNNUMBERED_INFORMATION_WITH_HEADER_CHECK = 0xef
  UNNUMBERED_INFORMATION_WITH_HEADER_CHECK_AND_POLL_FINAL = 0xff
    -- RFCOMM extension. With Poll/Final bit set in UIH control byte, a credits
    -- field is the first byte of the payload.

enum RfcommFixedChannel:
  [maximum_bits: 8]
  CONTROL = 0

enum RfcommCommandResponse:
  -- Commands from the initiator and responses from the responder
  -- have C/R = 0. Commands from the responder and responses from
  -- the initiator have C/R = 1.
  [maximum_bits: 1]
  COMMAND  = 0
  RESPONSE = 1

enum RfcommDirection:
  [maximum_bits: 1]
  RESPONDER = 0
  INITIATOR = 1

enum RfcommLengthExtended:
  [maximum_bits: 1]
  NORMAL = 1
  EXTENDED = 0

struct RfcommFrame:
  -- RFCOMM ETSI TS 07.10 frame
  [requires: extended_address == true]
  0    [+1]  bits:
    0  [+1]  Flag                   extended_address
    1  [+1]  RfcommCommandResponse  command_response
    2  [+1]  RfcommDirection        direction
    3  [+5]  UInt                   channel
      -- ETSI TS 07.10 section 5.2.1.2

  1    [+1]  RfcommFrameType        control
    -- ETSI TS 07.10 section 5.2.1.3

  2    [+1]  bits:
    0  [+1]  RfcommLengthExtended   length_extended_flag
    1  [+7]  UInt                   length
      -- ETSI TS 07.10 section 5.2.1.4

  if length_extended_flag == RfcommLengthExtended.EXTENDED:
    3  [+1]                UInt                     length_extended
      -- ETSI TS 07.10 section 5.2.1.4

  let information_length = $present(length_extended) ? length * 256 + length_extended : length
    -- Length of the '5.2.1.4 Information Field'. May include the RFCOMM credits
    -- field which appears at start.

  let credits_offset = $present(length_extended) ? 4 : 3
  if control == RfcommFrameType.UNNUMBERED_INFORMATION_WITH_HEADER_CHECK_AND_POLL_FINAL && channel != 0:
    credits_offset  [+1]                UInt                     credits
      -- Credits field can appears as first byte of information when Poll/Final
      -- bit is set on UIH frames and channel is not control (0).

  let payload_length = $present(credits) ? information_length - 1 : information_length
  let payload_offset = $present(credits) ? credits_offset + 1 : credits_offset
  payload_offset  [+payload_length]           UInt:8[payload_length]           payload
    -- Payload is the RFCOMM payload contained in the 'Information Field' which
    -- may start with credits.

  let fcs_offset = payload_offset + payload_length
  fcs_offset  [+1]  UInt                   fcs
    -- Frame checksum. See: GSM 07.10 TS 101 369 V6.3.0
    -- SABM, DISC, UA, DM frame types:
    --   FCS should be calculated over address, control and length fields.
    -- UIH frame type:
    --   FCS should be calculated over address and control fields.
